# 5장 DFS/BFS

## 문제풀이

```java
public class Main {
    static int n, m = 0;
    static int[][] maps;
    static boolean[][] visited;
    static int[][] move;
    static int dx[] = {-1, 0, 1, 0};
    static int dy[] = {0, -1, 0, 1};

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader((System.in)));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        Queue<int[]> q = new LinkedList<>();

        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        maps = new int[n][m];
        visited = new boolean[n][m];
        move = new int[n][m];

        for(int i = 0; i < n; i++){
            st = new StringTokenizer(br.readLine(), " ");
            for(int j = 0; j < m; j++){
                maps[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        q.add(new int[]{0,0});
        visited[0][0] = true;
        move[0][0] = 1;

        while(!q.isEmpty()){
            int[] next = q.poll();
            int x = next[0];
            int y = next[1];

            for(int i = 0; i < 4; i++){
               int x1 = x + dx[i];
               int y1 = y + dy[i];

               if(x1 < 0 || x1 >= n || y1 < 0 || y1 >= m) continue;
               if(visited[x1][y1]) continue;
               if(maps[x1][y1] == 0) continue;

               visited[x1][y1] = true;
               move[x1][y1] = move[x][y] + 1;
               q.add(new int[]{x1,y1});
            }
        }

        System.out.print(move[n-1][m-1]);
    }
}
```

## 미로 탈출

> 시간 제한 1초 | 메모리 제한 128MB

동빈이는 **N** X **M**크기의 직사각형 형태의 미로에 갖혀 있다. 미로에는 여러 마리의 괴물이 있어 이를 피해야 한다.
동빈이의 위치는 (1,1)이고 미로의 출구는 (N,M)의 위치에 존재하며 한번에 한 칸 씩 이동할 수 있다.
이때 괴물이 있는 부분은 0이고, 괴물이 없는 부분은 1로 표시되어 있다. 미로는 반드시 탈출할 수 있는 형태로 제시된다.
이때 동빈이가 탈출하기 위해 움직여야 하는 최소칸의 갯수를 구하시오. 칸을 셀 때는 시작 칸과 마지막칸을 모두 포함해서 게산한다.

입력 조건

- 첫째 줄에 두 정수 N,M(4<=N, M<=200)이 주어집니다. 다음 N개의 줄에는 각각 M개의 정수 혹은(0,혹은 1)로 미로의 정보가 주어진다.
- 각각의 수들은 공백 없이 붙어서 입력으로 제시된다.
- 또한 시작칸과 마지막칸은 항상 1이다.

출력 조건

- 첫째 줄에 최소 이동 칸의 개수를 출력한다.

| 입력 예시1  | 출력 예시1 |
| ----------- | ---------- |
| 5 6         |            |
| 1 0 1 0 1 0 |            |
| 1 1 1 1 1 1 |            |
| 0 0 0 0 0 1 |            |
| 1 1 1 1 1 1 |            |
| 1 1 1 1 1 1 | 10         |

[비슷한 문제: 백준(미로 탐색)](https://www.acmicpc.net/problem/2178)
